"""
Notification views for displaying and managing notifications.
Notifications are auto-generated by signals.
Views handle: display, read, delete, and clear operations (like Facebook).
"""
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.db.models import Q
from django.core.paginator import Paginator
from ..models import Notification, CustomUser

@login_required
def notification_center(request):
    """Display notifications for the user with filtering and pagination"""
    # Determine allowed notification types based on user role
    if request.user.is_site_admin:
        # Admins see all notifications
        notifications = Notification.objects.all().select_related('book', 'borrow', 'reservation', 'user').order_by('-created_at')
        allowed_notification_types = [choice[0] for choice in Notification.NOTIFICATION_TYPES]
    else:
        # Non-admins see only their own notifications
        notifications = Notification.objects.filter(
            user=request.user
        ).select_related('book', 'borrow', 'reservation').order_by('-created_at')
        # Restrict notification types for non-admins (e.g., exclude 'teacher_bulk_request' for non-teachers)
        allowed_notification_types = [
            'borrow_request',
            'borrow_approved',
            'borrow_rejected',
            'book_issued',
            'book_returned',
            'book_available',
            'reservation_fulfilled',
            'overdue_reminder',
        ]
        if request.user.is_teacher:
            allowed_notification_types.append('teacher_bulk_request')

    # Apply type filter
    notification_type = request.GET.get('type', '')
    if notification_type and notification_type in allowed_notification_types:
        notifications = notifications.filter(notification_type=notification_type)
    else:
        notification_type = ''  # Reset if invalid type for user

    # Apply status filter
    read_status = request.GET.get('status', '')
    if read_status == 'unread':
        notifications = notifications.filter(is_read=False)
    elif read_status == 'read':
        notifications = notifications.filter(is_read=True)

    # Pagination
    paginator = Paginator(notifications, 15)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Get unread count
    unread_count = Notification.objects.filter(
        user=request.user,
        is_read=False
    ).count()

    context = {
        'page_obj': page_obj,
        'unread_count': unread_count,
        'notification_type': notification_type,
        'read_status': read_status,
        'is_admin': request.user.is_site_admin,  # Pass admin status to template
        'allowed_notification_types': allowed_notification_types,  # Pass allowed types to template
    }

    return render(request, 'notifications/notification_center.html', context)


@login_required
@require_http_methods(["POST"])
def mark_notification_read(request, notification_id):
    """Mark a single notification as read"""
    notification = get_object_or_404(
        Notification,
        pk=notification_id,
        user=request.user
    )
    notification.mark_as_read()
    
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success'})
    
    return redirect('notification_center')


@login_required
@require_http_methods(["POST"])
def mark_all_notifications_read(request):
    """Mark all notifications as read"""
    Notification.objects.filter(
        user=request.user,
        is_read=False
    ).update(is_read=True)
    
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success'})
    
    return redirect('notification_center')


@login_required
@require_http_methods(["POST"])
def delete_notification(request, notification_id):
    """Delete a single notification"""
    notification = get_object_or_404(
        Notification,
        pk=notification_id,
        user=request.user
    )
    notification.delete()
    
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success'})
    
    return redirect('notification_center')


@login_required
@require_http_methods(["POST"])
def clear_all_notifications(request):
    """Delete all notifications for the user"""
    Notification.objects.filter(user=request.user).delete()
    
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success'})
    
    return redirect('notification_center')


@login_required
def get_unread_count(request):
    """Get unread notification count (for AJAX badge updates)"""
    unread_count = Notification.objects.filter(
        user=request.user,
        is_read=False
    ).count()
    
    return JsonResponse({
        'unread_count': unread_count
    })


@login_required
def get_recent_notifications(request):
    """Get recent notifications for dropdown preview (AJAX)"""
    notifications = Notification.objects.filter(
        user=request.user
    ).select_related('book').order_by('-created_at')[:5]
    
    data = {
        'notifications': [
            {
                'id': n.id,
                'message': n.message,
                'type': n.notification_type,
                'is_read': n.is_read,
                'created_at': n.created_at.isoformat(),
                'icon': n.get_icon(),
                'color': n.get_color(),
            }
            for n in notifications
        ]
    }
    
    return JsonResponse(data)
